import { fetchProducts } from "@/lib/testData";
import { Route } from "@/lib/types";
import { baseUrl, validateEnvironmentVariables } from "@/lib/utils";
import { MetadataRoute } from "next";

export const dynamic = "force-dynamic";

/**
 * Returns an array of route objects that define the sitemap for the storefront.
 *
 * Each route object must contain a `url` and a `lastModified` property.
 *
 * The `url` property is a string representing the URL of the route.
 *
 * The `lastModified` property is a string representing the last modified date of the route in ISO format.
 *
 * This function is called by Next.js to generate the sitemap for the storefront.
 *
 * The sitemap is generated by calling this function on the server-side and then serializing the returned array of route objects to XML.
 *
 * The sitemap is used by search engines to crawl the storefront and index the products.
 *
 * @returns {Promise<MetadataRoute.Sitemap>} A promise that resolves to an array of route objects that define the sitemap for the storefront.
 */
export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  validateEnvironmentVariables();

  const routesMap = [""].map((route) => ({
    url: `${baseUrl}${route}`,
    lastModified: new Date().toISOString(),
  }));

  //   const collectionsPromise = getCollections().then((collections) =>
  //     collections.map((collection) => ({
  //       url: `${baseUrl}${collection.path}`,
  //       lastModified: collection.updatedAt,
  //     }))
  //   );

  const productsPromise = fetchProducts().then((products) =>
    products.map((product) => ({
      url: `${baseUrl}/product/${product.handle}`,
      lastModified: product.updatedAt,
    }))
  );

  //   const pagesPromise = getPages().then((pages) =>
  //     pages.map((page) => ({
  //       url: `${baseUrl}/${page.handle}`,
  //       lastModified: page.updatedAt,
  //     }))
  //   );

  let fetchedRoutes: Route[] = [];

  try {
    // fetchedRoutes = (
    //   await Promise.all([collectionsPromise, productsPromise, pagesPromise])
    // ).flat();
  } catch (error) {
    throw JSON.stringify(error, null, 2);
  }

  return [...routesMap, ...fetchedRoutes];
}
